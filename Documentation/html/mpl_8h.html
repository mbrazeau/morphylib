<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MorphyLib: src/mpl.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">MorphyLib
   </div>
   <div id="projectbrief">Phylogenetic data reconstruction library accommodating inapplicable data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mpl_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mpl.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Defines the Morphy Phylogenetic Library API: a library for phylogenetic computation accommodating morphological character hierarchies.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;morphydefs.h&quot;</code><br />
<code>#include &quot;<a class="el" href="mplerror_8h_source.html">mplerror.h</a>&quot;</code><br />
</div>
<p><a href="mpl_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6cca1ea971c296d18aa7a8b795bc0ad0"><td class="memItemLeft" align="right" valign="top">Morphy&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#a6cca1ea971c296d18aa7a8b795bc0ad0">mpl_new_Morphy</a> (void)</td></tr>
<tr class="memdesc:a6cca1ea971c296d18aa7a8b795bc0ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of a Morphy object.  <a href="#a6cca1ea971c296d18aa7a8b795bc0ad0">More...</a><br /></td></tr>
<tr class="separator:a6cca1ea971c296d18aa7a8b795bc0ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0986d57153e9c860d5d3aee7d3f04d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#ae0986d57153e9c860d5d3aee7d3f04d1">mpl_delete_Morphy</a> (Morphy m)</td></tr>
<tr class="memdesc:ae0986d57153e9c860d5d3aee7d3f04d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys an instance of a Morphy object.  <a href="#ae0986d57153e9c860d5d3aee7d3f04d1">More...</a><br /></td></tr>
<tr class="separator:ae0986d57153e9c860d5d3aee7d3f04d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc4229ab15d94c71bace4c6abd54097"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#acbc4229ab15d94c71bace4c6abd54097">mpl_init_Morphy</a> (const int ntax, const int nchar, Morphy m)</td></tr>
<tr class="memdesc:acbc4229ab15d94c71bace4c6abd54097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up the dimensions of the dataset.  <a href="#acbc4229ab15d94c71bace4c6abd54097">More...</a><br /></td></tr>
<tr class="separator:acbc4229ab15d94c71bace4c6abd54097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8773ec59d25f741d90bfc742646361"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#acf8773ec59d25f741d90bfc742646361">mpl_get_numtaxa</a> (Morphy m)</td></tr>
<tr class="memdesc:acf8773ec59d25f741d90bfc742646361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of taxa (rows) in the dataset.  <a href="#acf8773ec59d25f741d90bfc742646361">More...</a><br /></td></tr>
<tr class="separator:acf8773ec59d25f741d90bfc742646361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7925e7a4688aafb2e611a41473c1ce8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#ae7925e7a4688aafb2e611a41473c1ce8">mpl_get_num_charac</a> (Morphy m)</td></tr>
<tr class="memdesc:ae7925e7a4688aafb2e611a41473c1ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the number of taxa (rows) in the dataset.  <a href="#ae7925e7a4688aafb2e611a41473c1ce8">More...</a><br /></td></tr>
<tr class="separator:ae7925e7a4688aafb2e611a41473c1ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee44c726cc2ce3553f4d3a70cae87fc6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#aee44c726cc2ce3553f4d3a70cae87fc6">mpl_set_num_internal_nodes</a> (const int nnodes, Morphy m)</td></tr>
<tr class="memdesc:aee44c726cc2ce3553f4d3a70cae87fc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of internal nodes in the dataset.  <a href="#aee44c726cc2ce3553f4d3a70cae87fc6">More...</a><br /></td></tr>
<tr class="separator:aee44c726cc2ce3553f4d3a70cae87fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6bcbde7cd1c01192362916ee402bd2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#ace6bcbde7cd1c01192362916ee402bd2">mpl_get_num_internal_nodes</a> (Morphy m)</td></tr>
<tr class="memdesc:ace6bcbde7cd1c01192362916ee402bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of internal nodal reconstruction sets being used by MorphyLib.  <a href="#ace6bcbde7cd1c01192362916ee402bd2">More...</a><br /></td></tr>
<tr class="separator:ace6bcbde7cd1c01192362916ee402bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a939ba16fd369ef29b542dd1ed3276659"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#a939ba16fd369ef29b542dd1ed3276659">mpl_attach_symbols</a> (const char *symbols, Morphy m)</td></tr>
<tr class="memdesc:a939ba16fd369ef29b542dd1ed3276659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach a caller-specified list of symbols.  <a href="#a939ba16fd369ef29b542dd1ed3276659">More...</a><br /></td></tr>
<tr class="separator:a939ba16fd369ef29b542dd1ed3276659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85b25984a956f6d865c1883b5810e0f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#af85b25984a956f6d865c1883b5810e0f">mpl_get_symbols</a> (const Morphy m)</td></tr>
<tr class="memdesc:af85b25984a956f6d865c1883b5810e0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the current list of symbols.  <a href="#af85b25984a956f6d865c1883b5810e0f">More...</a><br /></td></tr>
<tr class="separator:af85b25984a956f6d865c1883b5810e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6fcf4d3c9d71685d256ca50f17dc10d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#af6fcf4d3c9d71685d256ca50f17dc10d">mpl_attach_rawdata</a> (const char *rawmatrix, Morphy m)</td></tr>
<tr class="memdesc:af6fcf4d3c9d71685d256ca50f17dc10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attach raw character state data (i.e. tip data).  <a href="#af6fcf4d3c9d71685d256ca50f17dc10d">More...</a><br /></td></tr>
<tr class="separator:af6fcf4d3c9d71685d256ca50f17dc10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71609f95372f73398de955bc9b95bbf1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#a71609f95372f73398de955bc9b95bbf1">mpl_delete_rawdata</a> (Morphy m)</td></tr>
<tr class="memdesc:a71609f95372f73398de955bc9b95bbf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes the caller-input data.  <a href="#a71609f95372f73398de955bc9b95bbf1">More...</a><br /></td></tr>
<tr class="separator:a71609f95372f73398de955bc9b95bbf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86380377a2800f4e83dd5881e2203fa"><td class="memItemLeft" align="right" valign="top"><a id="aa86380377a2800f4e83dd5881e2203fa"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_set_gap_symbol</b> (const char gapsymb, Morphy m)</td></tr>
<tr class="separator:aa86380377a2800f4e83dd5881e2203fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7885987328c96e63be3439a8f7b0d9f"><td class="memItemLeft" align="right" valign="top"><a id="ac7885987328c96e63be3439a8f7b0d9f"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_set_missing_symbol</b> (const char missymb, Morphy m)</td></tr>
<tr class="separator:ac7885987328c96e63be3439a8f7b0d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fd3b98a7eb5f020f63e87f35b3dfe36"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#a9fd3b98a7eb5f020f63e87f35b3dfe36">mpl_apply_tipdata</a> (Morphy m)</td></tr>
<tr class="memdesc:a9fd3b98a7eb5f020f63e87f35b3dfe36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits parameters prior to nodal set calculations.  <a href="#a9fd3b98a7eb5f020f63e87f35b3dfe36">More...</a><br /></td></tr>
<tr class="separator:a9fd3b98a7eb5f020f63e87f35b3dfe36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106ed25dcd73a478453d5e9cce1f886e"><td class="memItemLeft" align="right" valign="top"><a id="a106ed25dcd73a478453d5e9cce1f886e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_incl_charac</b> (const int charID, Morphy m)</td></tr>
<tr class="separator:a106ed25dcd73a478453d5e9cce1f886e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e75433625d62baee5bb2643a81de486"><td class="memItemLeft" align="right" valign="top"><a id="a6e75433625d62baee5bb2643a81de486"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_excl_charac</b> (const int charID, Morphy m)</td></tr>
<tr class="separator:a6e75433625d62baee5bb2643a81de486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99083a721f38a7fd05b74e72e4447497"><td class="memItemLeft" align="right" valign="top"><a id="a99083a721f38a7fd05b74e72e4447497"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_set_charac_weight</b> (const int charID, Mflt weight)</td></tr>
<tr class="separator:a99083a721f38a7fd05b74e72e4447497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c57f8bd72df7991d9a6acf811332c9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#a85c57f8bd72df7991d9a6acf811332c9">mpl_set_parsim_t</a> (const int charID, const MPLchtype chtype, Morphy m)</td></tr>
<tr class="memdesc:a85c57f8bd72df7991d9a6acf811332c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a character's parsimony function type.  <a href="#a85c57f8bd72df7991d9a6acf811332c9">More...</a><br /></td></tr>
<tr class="separator:a85c57f8bd72df7991d9a6acf811332c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8043dd4239f82aec52c1512b62366e"><td class="memItemLeft" align="right" valign="top"><a id="adb8043dd4239f82aec52c1512b62366e"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_set_gaphandl</b> (const gap_t gaptype, Morphy m)</td></tr>
<tr class="separator:adb8043dd4239f82aec52c1512b62366e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7096c2c0f83374bdd588efc2dba5a8"><td class="memItemLeft" align="right" valign="top"><a id="a7e7096c2c0f83374bdd588efc2dba5a8"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_query_gaphandl</b> (Morphy m)</td></tr>
<tr class="separator:a7e7096c2c0f83374bdd588efc2dba5a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef08c9fefa44b7774de8eb84c8434fa1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#aef08c9fefa44b7774de8eb84c8434fa1">mpl_first_down_recon</a> (const int node_id, const int left_id, const int right_id, Morphy m)</td></tr>
<tr class="memdesc:aef08c9fefa44b7774de8eb84c8434fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the first (downpass) nodal reconstructions.  <a href="#aef08c9fefa44b7774de8eb84c8434fa1">More...</a><br /></td></tr>
<tr class="separator:aef08c9fefa44b7774de8eb84c8434fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64671d77342cfbea87f0939f202edd02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#a64671d77342cfbea87f0939f202edd02">mpl_first_up_recon</a> (const int node_id, const int left_id, const int right_id, const int anc_id, Morphy m)</td></tr>
<tr class="memdesc:a64671d77342cfbea87f0939f202edd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reconstructs the second (uppass) nodal reconstructions.  <a href="#a64671d77342cfbea87f0939f202edd02">More...</a><br /></td></tr>
<tr class="separator:a64671d77342cfbea87f0939f202edd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bae5d3fec1ca60a94e849dc8e3c1297"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#a8bae5d3fec1ca60a94e849dc8e3c1297">mpl_second_down_recon</a> (const int node_id, const int left_id, const int right_id, Morphy m)</td></tr>
<tr class="memdesc:a8bae5d3fec1ca60a94e849dc8e3c1297"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the second nodal reconstructions for characters with inapplicability.  <a href="#a8bae5d3fec1ca60a94e849dc8e3c1297">More...</a><br /></td></tr>
<tr class="separator:a8bae5d3fec1ca60a94e849dc8e3c1297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66caa7ae70f6acebc1c0323378d5a787"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#a66caa7ae70f6acebc1c0323378d5a787">mpl_second_up_recon</a> (const int node_id, const int left_id, const int right_id, const int anc_id, Morphy m)</td></tr>
<tr class="memdesc:a66caa7ae70f6acebc1c0323378d5a787"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalises the ancestral state reconstructions for characters with inapplicable values.  <a href="#a66caa7ae70f6acebc1c0323378d5a787">More...</a><br /></td></tr>
<tr class="separator:a66caa7ae70f6acebc1c0323378d5a787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ac2fcc04ca401d71943f7027b10ca8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#ae2ac2fcc04ca401d71943f7027b10ca8">mpl_update_tip</a> (const int tip_id, const int anc_id, Morphy m)</td></tr>
<tr class="memdesc:ae2ac2fcc04ca401d71943f7027b10ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial update of tip values following uppass reconstruction.  <a href="#ae2ac2fcc04ca401d71943f7027b10ca8">More...</a><br /></td></tr>
<tr class="separator:ae2ac2fcc04ca401d71943f7027b10ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb23fc933cb5c48a6dcc1ae4ca398c6a"><td class="memItemLeft" align="right" valign="top"><a id="afb23fc933cb5c48a6dcc1ae4ca398c6a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_finalize_tip</b> (const int tip_id, const int anc_id, Morphy m)</td></tr>
<tr class="separator:afb23fc933cb5c48a6dcc1ae4ca398c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b74263442cdbe08d9b11c72c1082177"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpl_8h.html#a0b74263442cdbe08d9b11c72c1082177">mpl_update_lower_root</a> (const int l_root_id, const int root_id, Morphy m)</td></tr>
<tr class="memdesc:a0b74263442cdbe08d9b11c72c1082177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates the nodal sets for a lower ('dummy') root node.  <a href="#a0b74263442cdbe08d9b11c72c1082177">More...</a><br /></td></tr>
<tr class="separator:a0b74263442cdbe08d9b11c72c1082177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1992f1e0d743fbbc0fb9a6b03576e3"><td class="memItemLeft" align="right" valign="top"><a id="a6c1992f1e0d743fbbc0fb9a6b03576e3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_get_insertcost</b> (const int srcID, const int tgt1ID, const int tgt2ID, bool max, int cutoff, Morphy m)</td></tr>
<tr class="separator:a6c1992f1e0d743fbbc0fb9a6b03576e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9aecd2c57c4852ce3066b661a8a305"><td class="memItemLeft" align="right" valign="top"><a id="aad9aecd2c57c4852ce3066b661a8a305"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_get_packed_states</b> (const int nodeID, const int character, int passnum, Morphy m)</td></tr>
<tr class="separator:aad9aecd2c57c4852ce3066b661a8a305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286851ea0d19953597d206f3e6083916"><td class="memItemLeft" align="right" valign="top"><a id="a286851ea0d19953597d206f3e6083916"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>mpl_get_stateset</b> (char *res, const int nodeID, const int character, int passnum, Morphy m)</td></tr>
<tr class="separator:a286851ea0d19953597d206f3e6083916"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Defines the Morphy Phylogenetic Library API: a library for phylogenetic computation accommodating morphological character hierarchies. </p>
<p>Copyright (C) 2017 Martin D. Brazeau</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.</p>
<p>This header includes all the externally exported definitions and function prototypes. A calling program creates an instance of a Morphy object and interacts with its elements through the functions described in this interface. The Morphy object contains no tree objects, but requires a pre-specified list of indices (integers) corresponding to the node indices in the calling program. Morphy will not keep track of the relationships between the nodes, and it is up to the caller to keep track of these. Each character must* be assigned a type, and Morphy will make no default assumptions. Once one or more characters are assigned a function type (which creates internal partitions), and a postorder list of nodes is known, then the library functions can be called to reconstruct state sets and deliver length estimates for each node.</p>
<p>Morphy will provide functions for local reoptimisation, partial reoptimisation and optimisation of subtrees. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9fd3b98a7eb5f020f63e87f35b3dfe36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fd3b98a7eb5f020f63e87f35b3dfe36">&#9670;&nbsp;</a></span>mpl_apply_tipdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_apply_tipdata </td>
          <td>(</td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commits parameters prior to nodal set calculations. </p>
<p>Once the caller is satisfied with the setup of types, weights, and partitioning, this function must be called, thereby committing the parameters until any changes are made. If no character types have been assigned, the function will fail with an error code.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Morphy error code. </dd></dl>

</div>
</div>
<a id="af6fcf4d3c9d71685d256ca50f17dc10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6fcf4d3c9d71685d256ca50f17dc10d">&#9670;&nbsp;</a></span>mpl_attach_rawdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_attach_rawdata </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rawmatrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach raw character state data (i.e. tip data). </p>
<p>Attaches a raw data character state matrix in the form of a C-style (i.e. NULL-terminated string). This can be the matrix block extracted from a Nexus file or an xread table format. The matrix should contain no terminal or tip labels.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rawmatrix</td><td>C-style string corresponding to the tip data.</td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Morphy error code. </dd></dl>

</div>
</div>
<a id="a939ba16fd369ef29b542dd1ed3276659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a939ba16fd369ef29b542dd1ed3276659">&#9670;&nbsp;</a></span>mpl_attach_symbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_attach_symbols </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>symbols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attach a caller-specified list of symbols. </p>
<p>Allows the caller to specify a list of symbols in the data matrix, otherwise, the symbols list used by Morphy will be extracted from the matrix. The symbols list must match the symbols provided in the matrix. When Morphy extracts symbols from the matrix, their ordering is alphanumeric, according to their ASCII codes (i.e. "+0123...ABCD...abcd..."). Loading a user-specified symbols list will override this ordering. Symbols loaded in either the list or the matrix must be valid Morphy character state symbols as defined in the <a class="el" href="statedata_8h_source.html">statedata.h</a> header file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">symbols</td><td>A C-style (i.e. NULL-terminated) string of valid state symbols.</td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Morphy error code. </dd></dl>

</div>
</div>
<a id="ae0986d57153e9c860d5d3aee7d3f04d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0986d57153e9c860d5d3aee7d3f04d1">&#9670;&nbsp;</a></span>mpl_delete_Morphy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_delete_Morphy </td>
          <td>(</td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys an instance of a Morphy object. </p>
<p>Destroys an instance of the Morphy object, calling all destructors for internal object completely returning the memory to the system.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>A Morphy object to be destroyed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Morphy error code. </dd></dl>

</div>
</div>
<a id="a71609f95372f73398de955bc9b95bbf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71609f95372f73398de955bc9b95bbf1">&#9670;&nbsp;</a></span>mpl_delete_rawdata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_delete_rawdata </td>
          <td>(</td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Deletes the caller-input data. </p>
<p>Deletes all of the user-input data and restores all parameters to their original values, except for the dimensions of the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Morphy error code. </dd></dl>

</div>
</div>
<a id="aef08c9fefa44b7774de8eb84c8434fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef08c9fefa44b7774de8eb84c8434fa1">&#9670;&nbsp;</a></span>mpl_first_down_recon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_first_down_recon </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>left_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>right_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs the first (downpass) nodal reconstructions. </p>
<p>Reconstructs the preliminary nodal set for all characters for a particular node. This function is called over a postorder sequence of internal nodes where left and right descendants are known.</p>
<p>Because this function needs to be fairly high-performance, it does not do much checking for parameter validity, thus unsafe usage of this function might not be caught. It is up to calling functions to ensure that the appropriate parameters have been set before use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>The index of the node being reconstructed.</td></tr>
    <tr><td class="paramname">left_id</td><td>The index of the left descendant.</td></tr>
    <tr><td class="paramname">right_id</td><td>The index of the right descendant.</td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral parsimony length (right now) </dd></dl>

</div>
</div>
<a id="a64671d77342cfbea87f0939f202edd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64671d77342cfbea87f0939f202edd02">&#9670;&nbsp;</a></span>mpl_first_up_recon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_first_up_recon </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>left_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>right_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>anc_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reconstructs the second (uppass) nodal reconstructions. </p>
<p>Reconstructs second-pass nodal sets. For normal (all-applicable) characters, this is the final pass. This function is called over a preorder sequence of nodes where left, right, and ancestral nodes are known.</p>
<p>Because this function needs to be fairly high-performance, it does not do much checking for parameter validity, thus unsafe usage of this function might not be caught. It is up to calling functions to ensure that the appropriate parameters have been set before use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>The index of the node being reconstructed.</td></tr>
    <tr><td class="paramname">left_id</td><td>The index of the left descendant.</td></tr>
    <tr><td class="paramname">right_id</td><td>The index of the right descendant.</td></tr>
    <tr><td class="paramname">anc_id</td><td>The index of the immediate ancestor of the node.</td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A null value (for now). </dd></dl>

</div>
</div>
<a id="ae7925e7a4688aafb2e611a41473c1ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7925e7a4688aafb2e611a41473c1ce8">&#9670;&nbsp;</a></span>mpl_get_num_charac()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_get_num_charac </td>
          <td>(</td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of taxa (rows) in the dataset. </p>
<p>Retrieves the number of taxa (rows) in the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of taxa if success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="ace6bcbde7cd1c01192362916ee402bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6bcbde7cd1c01192362916ee402bd2">&#9670;&nbsp;</a></span>mpl_get_num_internal_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_get_num_internal_nodes </td>
          <td>(</td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the number of internal nodal reconstruction sets being used by MorphyLib. </p>
<p>Gets the number of internal nodal reconstruction sets being used by MorphyLib.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of internal nodes. </dd></dl>

</div>
</div>
<a id="acf8773ec59d25f741d90bfc742646361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8773ec59d25f741d90bfc742646361">&#9670;&nbsp;</a></span>mpl_get_numtaxa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_get_numtaxa </td>
          <td>(</td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the number of taxa (rows) in the dataset. </p>
<p>Retrieves the number of taxa (rows) in the dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of taxa if success, otherwise an error code. </dd></dl>

</div>
</div>
<a id="af85b25984a956f6d865c1883b5810e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85b25984a956f6d865c1883b5810e0f">&#9670;&nbsp;</a></span>mpl_get_symbols()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpl_get_symbols </td>
          <td>(</td>
          <td class="paramtype">const Morphy&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the current list of symbols. </p>
<p>Returns a pointer to the string of character state symbols currently being used by Morphy (i.e. either the list of symbols extracted from the matrix, or the caller-specified values).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A C-style (null-terminated) string of the character state symbols being used. NULL if failure. </dd></dl>

</div>
</div>
<a id="acbc4229ab15d94c71bace4c6abd54097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbc4229ab15d94c71bace4c6abd54097">&#9670;&nbsp;</a></span>mpl_init_Morphy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_init_Morphy </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>ntax</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up the dimensions of the dataset. </p>
<p>Provides initial dimensions for the dataset, which will constrain any input matrix supplied to Morphy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ntax</td><td>The number of taxa (or tips/terminals).</td></tr>
    <tr><td class="paramname">nchar</td><td>The number of characters (i.e. transformation series) in the data set.</td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Morphy error code. </dd></dl>

</div>
</div>
<a id="a6cca1ea971c296d18aa7a8b795bc0ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cca1ea971c296d18aa7a8b795bc0ad0">&#9670;&nbsp;</a></span>mpl_new_Morphy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Morphy mpl_new_Morphy </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of a Morphy object. </p>
<p>Creates a new empty Morphy object. All fields are unpopulated and uninitialised.</p>
<dl class="section return"><dt>Returns</dt><dd>A void pointer to the Morphy instance. NULL if unsuccessful. </dd></dl>

</div>
</div>
<a id="a8bae5d3fec1ca60a94e849dc8e3c1297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bae5d3fec1ca60a94e849dc8e3c1297">&#9670;&nbsp;</a></span>mpl_second_down_recon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_second_down_recon </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>left_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>right_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the second nodal reconstructions for characters with inapplicability. </p>
<p>Updates the nodal sets that had ambiguous unions with the inapplicable state and calculates steps involving applicable states after the update.</p>
<p>Because this function needs to be fairly high-performance, it does not do much checking for parameter validity, thus unsafe usage of this function might not be caught. It is up to calling functions to ensure that the appropriate parameters have been set before use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>The index of the node being reconstructed.</td></tr>
    <tr><td class="paramname">left_id</td><td>The index of the left descendant.</td></tr>
    <tr><td class="paramname">right_id</td><td>The index of the right descendant.</td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral parsimony length (right now) </dd></dl>

</div>
</div>
<a id="a66caa7ae70f6acebc1c0323378d5a787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66caa7ae70f6acebc1c0323378d5a787">&#9670;&nbsp;</a></span>mpl_second_up_recon()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_second_up_recon </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>left_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>right_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>anc_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalises the ancestral state reconstructions for characters with inapplicable values. </p>
<p>Finalises the nodal sets for any characters that may have involved the inapplicable token and counts excess regions of applicability at nodes having at least two descendant subtrees that possess any applicable characters.</p>
<p>Because this function needs to be fairly high-performance, it does not do much checking for parameter validity, thus unsafe usage of this function might not be caught. It is up to calling functions to ensure that the appropriate parameters have been set before use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>The index of the node being reconstructed.</td></tr>
    <tr><td class="paramname">left_id</td><td>The index of the left descendant.</td></tr>
    <tr><td class="paramname">right_id</td><td>The index of the right descendant.</td></tr>
    <tr><td class="paramname">anc_id</td><td>The index of the immediate ancestor of the node.</td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The integral parsimony length (for now) </dd></dl>

</div>
</div>
<a id="aee44c726cc2ce3553f4d3a70cae87fc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee44c726cc2ce3553f4d3a70cae87fc6">&#9670;&nbsp;</a></span>mpl_set_num_internal_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_set_num_internal_nodes </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>nnodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of internal nodes in the dataset. </p>
<p>This specifies the number of internal nodes over which reconstruction sets need to be made. It is up to the caller to ensure the correct number of nodes and the relationships between them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nnodes</td><td>The desired number of internal nodes.</td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Morphy error code. </dd></dl>

</div>
</div>
<a id="a85c57f8bd72df7991d9a6acf811332c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c57f8bd72df7991d9a6acf811332c9">&#9670;&nbsp;</a></span>mpl_set_parsim_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_set_parsim_t </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>charID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPLchtype&#160;</td>
          <td class="paramname"><em>chtype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a character's parsimony function type. </p>
<p>Set the parsimony function type to one defined in the <a class="el" href="morphydefs_8h_source.html">morphydefs.h</a> header file. Setting the character to type NONE_T will also cause it to be excluded from any further calculations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">charID</td><td>The index of the character (transformation series) as defined in the input matrix.</td></tr>
    <tr><td class="paramname">chtype</td><td>The parsimony function type as defined in <a class="el" href="morphydefs_8h_source.html">morphydefs.h</a></td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Morphy error code. </dd></dl>

</div>
</div>
<a id="a0b74263442cdbe08d9b11c72c1082177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b74263442cdbe08d9b11c72c1082177">&#9670;&nbsp;</a></span>mpl_update_lower_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_update_lower_root </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>l_root_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>root_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Updates the nodal sets for a lower ('dummy') root node. </p>
<p>If trees are rooted, then Morphy uppass functions require a lower or 'dummy' root in order to function properly. This function should be called to set the nodal state sets to the dummy root. The nodal set will be equal to the set of the root node, unless there is an ambiguous union of applicable and gap tokens when gaps are treated as in applicable. In which case, the set union is resolved in favour of any applicable tokens in the set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">l_root_id</td><td>The index of the lower root.</td></tr>
    <tr><td class="paramname">root_id</td><td>The index of the upper root node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A Morphy error code. </dd></dl>

</div>
</div>
<a id="ae2ac2fcc04ca401d71943f7027b10ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ac2fcc04ca401d71943f7027b10ca8">&#9670;&nbsp;</a></span>mpl_update_tip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpl_update_tip </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>tip_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>anc_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Morphy&#160;</td>
          <td class="paramname"><em>m</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial update of tip values following uppass reconstruction. </p>
<p>Ambiguous terminal state sets need to be resolved after the uppass based on descendant state values in order for local reoptimisation procedures to be accurate and for inapplicable step counting to proceed accurately. This function calls updaters for the records of states active on the subtrees, thereby allowing the second downpass to accurately reconstruct subtree state activity.</p>
<p>Because this function needs to be fairly high-performance, it does not do much checking for parameter validity, thus unsafe usage of this function might not be caught. It is up to calling functions to ensure that the appropriate parameters have been set before use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tip_id</td><td>The index of the tip being updated.</td></tr>
    <tr><td class="paramname">anc_id</td><td>The index of the tip's immediate ancestor.</td></tr>
    <tr><td class="paramname">m</td><td>An instance of the Morphy object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A null value (for now). </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="mpl_8h.html">mpl.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
